---
title: "Malware & Threat Landscape: Detection, Analysis, and Mitigation"
date: 2024-03-25
draft: false
summary: "An in-depth examination of malware types, persistence mechanisms, and practical detection techniques using Wireshark and other tools."
---

![Malware header image](/images/malware-threat/header.jpg)

# Malware & Threat Landscape: Detection, Analysis, and Mitigation

In today’s interconnected world, malware authors continuously evolve their techniques, leveraging new vulnerabilities and evasion strategies to infiltrate systems. From simple viruses that attach to executable files to sophisticated, targeted rootkits or ransomware, understanding the entire threat landscape—along with practical hands,on analysis—is essential for security practitioners. This article covers fundamental concepts of threats and vulnerabilities, describes common malware families, based on sources and literature used in my cybersecurity lectures and research throughout the spring. We also try to demonstrates how to detect malicious network activity with Wireshark and hex analysis, and offers mitigation strategies to protect the environment in which we are operating.

# Threat & Vulnerability Primer

A **threat** is any potential adverse event or actor capable of exploiting a vulnerability, whereas a **vulnerability** is a weakness in a system, application, network, or process that can be leveraged to compromise confidentiality, integrity, or availability (the C-I-A triad). Understanding both concepts is crucial for effective defense:

- **Confidentiality** ensures that sensitive information is accessed only by authorized parties.  
- **Integrity** ensures that information remains unaltered except by authorized actions.  
- **Availability** guarantees that services and data remain accessible when needed.  

Common examples of threats include Denial-of-Service (DoS) attacks—where an attacker floods a server with junk traffic to render it unusable—and Distributed Denial-of-Service (DDoS), which leverages multiple compromised hosts (botnets) to amplify the attack. In a typical **SYN flood**, an attacker sends a torrent of TCP SYN packets, consuming the target’s connection table and preventing legitimate connections from completing their three-way handshake.

Vulnerabilities range from unpatched software with known exploits (e.g., a remote code execution flaw) to misconfigurations (open ports that shouldn’t be exposed) and even social engineering weaknesses (phishing). A thorough security posture requires identifying and ranking vulnerabilities—often via regular vulnerability scans—and then applying appropriate patches, configurations, or compensating controls.

# Malware Taxonomy & Real-World Examples

Malware can be broadly classified by its behavior and propagation method. Familiarity with each category helps in choosing the right detection and mitigation tools.

## Worms  
**Definition:** Worms are self-replicating malware that spread across networks by exploiting vulnerabilities.  
- **Example: Stuxnet** targeted Siemens PLCs by using multiple zero-day exploits to propagate via removable media (USB sticks) and network shares. Once inside, it manipulated programmable logic controllers to sabotage industrial equipment without immediate detection.  

## Viruses  
**Definition:** Viruses attach to legitimate host files (executables, documents with macros) and require user action to propagate (e.g., opening an infected file).  
- **Example: EICAR Test File** is a harmless string used to test antivirus software. By creating a file that matches EICAR’s signature, you can verify whether antivirus tools detect it as malicious.

## Trojans  
**Definition:** Trojans masquerade as useful software or hide within seemingly benign programs. They rely on social engineering to trick users into executing them.  
- **Example: Dridex** delivered via malicious email attachments (often Microsoft Office documents with embedded macros). Once installed, it hijacks browser processes to steal online banking credentials using WebInject techniques.

## Rootkits & Backdoors  
**Definition:** Rootkits hide their presence by subverting operating system primitives (e.g., kernel modules, hooking system calls). Backdoors provide remote access to an infected host.  
- **Example: Reptile Rootkit** operates at the kernel level, intercepting system calls to conceal processes, files, and registry entries. It then opens a stealthy command-and-control (C&C) channel for remote manipulation.

## Ransomware  
**Definition:** Ransomware encrypts user data and demands payment (often in cryptocurrency) to restore access. Modern variants may also exfiltrate data for double extortion.  
- **Example: WannaCry** leveraged the EternalBlue SMB vulnerability to propagate rapidly across unpatched Windows networks. Victims saw their files encrypted and a ransom note demanding Bitcoin payment.

## Spyware & Adware  
**Definition:** Spyware collects user information (keystrokes, browsing habits) without consent; adware displays unwanted advertisements, often bundling additional spyware.  
- **Example: JSWorm** is a Windows desktop Trojan that logs keystrokes and periodically exfiltrates data to a remote server, all while remaining stealthy.

## Bots & Botnets  
**Definition:** Bots are malware installed on numerous compromised hosts; a network of bots (botnet) can be used for large-scale campaigns (spam, DDoS, click fraud).  
- **Example: Necurs Botnet** delivered a variety of malware, from banking Trojans to ransomware, by sending massive spam campaigns.

## Logic Bombs & C&C Infrastructure  
**Definition:** Logic bombs lie dormant until triggered by a specific event (date, time, or specific system condition). C&C infrastructure refers to servers and protocols malware authors use to coordinate bots or receive exfiltrated data.  
- **Example: A logic bomb embedded in a legitimate installer that activates on a preset date to delete or encrypt critical files.**

# Persistence Mechanisms

Once an attacker’s code executes, achieving persistence ensures it remains active across reboots and evades casual detection.

## Windows Persistence  
- **Registry “Run” Keys:** Malware often adds entries under `HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run` or user equivalents, causing executables or scripts to launch at logon.  
- **Windows Services:** Installing a malicious service is highly effective; services run with SYSTEM privileges and can start before user login.  
- **Scheduled Tasks:** Attackers create or hijack scheduled tasks (`schtasks.exe`) to execute payloads on a regular cadence or at startup.  

## Linux Persistence  
- **Cron Jobs:** By adding entries to `/etc/crontab` or a user’s `crontab -e`, malware can run shell scripts or binaries at specified intervals.  
- **Init Scripts / Systemd Units:** Dropping a script into `/etc/init.d/` (SysVinit) or creating a custom `.service` file under `/etc/systemd/system/` allows execution on boot.  
- **User Profile Scripts:** Modifying `~/.bashrc` or `/etc/profile` causes code to run each time the user spawns a shell.  

Understanding these mechanisms is important both for red-teamers designing persistence and blue-teamers hunting for indicators of compromise (IoCs).

# Hands-On Malware Analysis with Wireshark

<img src="/images/malware-threat/1.jpg"
     alt="a simple game application"
     width="300" />

Network traffic analysis remains one of the most powerful ways to detect active malware. In the following example, we capture traffic from 2 custom “game” applications to illustrate how seemingly innocent protocols can leak important data. The first game is as shown above, capturing scores and checking for system requirements, while the other is a number guessing game written with python. The games itself are not too relevant, but the methods used below to showcase some interesting aspects are what is important. 

1. **Capturing Traffic**  
   - From Kali, I opened WireShark and start a session listening on the `eth0` interface. Initially, no traffic appears when clicking “Play” or “Highscores” in the game.  
   - In Wireshark, I apply the filter `http.request` to isolate HTTP traffic. Upon clicking “System Requirements” within the game, a TCP connection is initiated, to some unknown machine (noted with the IP 172.21.8.10, while Kali has as we see the IP 172.21.9.31). 

<img src="/images/malware-threat/2.jpg"
     alt="WireShark capture on eth0"
     width="900" />

2. **Identifying OS Fingerprints**  
   - In the first HTTP packet, we can inspect the request headers. The `User-Agent` field reveals `WINDOWS10`. This informs us that the machine we opened a TCP connection to is running Windows 10. 

<img src="/images/malware-threat/5.jpg"
     alt="WireShark capture on eth0"
     width="900" />

<img src="/images/malware-threat/3.jpg"
     alt="OS information"
     width="500" />

3. **Extracting Hidden Tokens**  
   In a different small application, the game just consists of a number guessing game. The user writes numbers, and the game continues in a eternally lasting loop to say if its correct or not. The game seems to be a linux executable, but some odd information is found from its source code, although scrambled. 

    <img src="/images/malware-threat/6.jpg"
     alt="Token information"
     width="700" />

However, by setting up WireShark to listen on the interface Kali is using (still eth0), we see there is some traffic that has appeared after starting the seemingly innocent game. Inspecting the TCP-handshake we see information about a TCP payload. To get a better view, following the TCP stream (`Follow → TCP Stream`), we locate a payload segment containing `TOKEN=Pr0gr4ms_B3having_Bad`. This token is likely an authentication or session identifier used by the malware back end. Instead of sending a well-formed HTTP request, it simply writes a line of text plus a token:  

     ```
     Your sensitive personal information.
     TOKEN=Pr0gr4ms_B3having_Bad
     ```

Because this payload doesn’t start with `GET / HTTP/1.1…`, the web server immediately responds with:

     ```
     HTTP/1.1 400 Bad Request
     Date: Wed, 07 Feb 2024 14:21:42 GMT
     Server: Apache/2.4.10 (Debian)
     Content-Length: 302
     Connection: close
     Content-Type: text/html; charset=iso-8859-1

     <!DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”>
     <html><head><title>400 Bad Request</title></head><body>
     <h1>Bad Request</h1>
     <p>Your browser sent a request that this server could not understand.<br /></p>
     <hr><address>Apache/2.4.10 (Debian) Server at 172.21.0.3 Port 80</address>
     </body></html>
     ```
By right-clicking on the TCP packet and choosing **Analyze → Follow → TCP Stream**, we see the raw text (including `TOKEN=Pr0gr4ms_B3having_Bad`) before the `400 Bad Request` response.  
     
 <img src="/images/malware-threat/4.jpg"
     alt="Token information"
     width="700" />

**Takeaway:** Even though the server rejects the malformed request, the token is sent in the clear. A real malware analyst sniffing the wire would pick up that token (or any other embedded C&C indicator) just as easily.

# Hex Dump & String Extraction

Static analysis of a malware binary can give critical clues without executing it. Using tools like `hexdump` and `strings` in a controlled environment, we can peek inside the file structure.

On the Kali VM, I had a malware sample stored under `/usr/share/malware-samples/`. Assume we identify a suspicious file named `malicious.bin`.

Using hexdump, or xxd, we can quickly view the file hexadecimal values, and to some extent the cleartext content where its readable. 

```bash
$ hexdump -C malicious.bin | head -n 20
00000000  4d 5a 90 00 03 00 00 00  04 00 00 00 ff ff 00 00  |MZ..............|
00000010  b8 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
```

The 4D 5A (“MZ”) header confirms this is a Windows PE executable. A great source I have used previously to get more data on file signatures, is Gary Kesslers GCK file signature list,<a href="https://www.garykessler.net/library/file_sigs_GCK_latest.html" target="_blank" rel="noopener noreferrer"> link to website (opens a new window)</a>.

# Mitigation & Detection Strategies

Having gone through a few quick and easy examples, this needs to be further explored in practical labs. While not included in this article, I will add similar labs at a later point. Having explored the litterature on how malware functions and very briefly showing how to analyze it, let’s discuss layered defenses that combine network, endpoint, and user-focused measures.

## Network-Level Defenses

Intrusion Detection/Prevention Systems (IDS/IPS): Tools like Snort or Suricata can detect known malicious signatures (e.g., C&C domain names) and anomalous patterns (e.g., port scanning).

Firewall Rules & Segmentation: Restrict outbound traffic to only necessary destinations. For instance, a workstation shouldn’t be permitted to initiate connections on non-standard ports.

DNS Filtering & Sinkholing: Block or redirect requests to known malicious domains. Services like Pi-Hole or corporate DNS appliances can enforce domain-level policies.

## Endpoint Protection

Signature-Based Antivirus/Antimalware: Maintain up-to-date signature databases so that checksums (MD5, SHA-256) of known malware are detected before execution.

Behavioral Analysis & EDR (Endpoint Detection & Response): Solutions like CrowdStrike Falcon or Microsoft Defender for Endpoint observe process behavior in real time, flagging suspicious actions (e.g., a Word process spawning PowerShell).

Application Whitelisting: Limit execution to explicitly approved software. Even if an attacker gains access, unauthorized binaries will be prevented from running.

## Patching & Hardening

Timely Updates: Regularly apply operating system and application patches. Vulnerabilities like EternalBlue (MS17-010) remain prevalent only because unpatched systems persist in the wild.

Disable Unnecessary Services: If SMBv1 is not required, disable it completely. Minimize attack surface by turning off file shares or remote desktop if they’re not in use.

Least Privilege & Role-Based Access Control (RBAC): Ensure users run with non-administrative accounts. Even if malware executes, its ability to write to critical system areas is limited.

## User Awareness & Training

Phishing Simulations: Conduct periodic tests to gauge employee susceptibility and provide immediate feedback.

Safe Browsing Practices: Encourage individuals to hover over links before clicking, verify sender addresses, and treat unexpected attachments with suspicion.

Reporting Channels: Establish a clear process for users to report suspected phishing emails or unusual system behavior.

# Spam (Junk Mail) as a Delivery Vector

Spam and phishing campaigns remain the primary distribution method for Trojans, ransomware, and other malware. Understanding how spam is generated and delivered helps in constructing defenses:

Botnets for Bulk Mail: Compromised hosts—often running spam-sending malware—relay massive volumes of unsolicited email.

Harvesting Email Addresses: Attackers scan webpages, forums, and breached databases to collect large lists of targets.

Spear Phishing vs. Mass Spam: While mass spam casts a wide net (hoping for a tiny click-through rate), spear phishing targets specific individuals with personalized lures (e.g., “Invoice attached for March services”).

Economic Incentive: Even if only 0.01% of recipients click a malicious link, the ROI on a campaign sending millions of messages is often positive.

Deploying spam filters (e.g., SpamAssassin, Microsoft Exchange Online Protection) and enforcing DMARC, DKIM, and SPF records for outbound domains reduces both incoming spam and domain spoofing.

# Real-World Incident Case Study: Stuxnet

Stuxnet represents a watershed moment in cyber warfare. Discovered in 2010, it was designed to sabotage Iran’s nuclear enrichment centrifuges by manipulating programmable logic controllers (PLCs).

Zero-Day Exploits & Propagation
Stuxnet leveraged multiple zero-day vulnerabilities in Windows, including a print spooler flaw and an LNK vulnerability that allowed code execution merely by viewing a USB drive’s contents in Explorer. This enabled it to spread via removable media and local networks undetected.

DLL Hijacking & Rootkit Techniques
By installing a rootkit on infected systems, Stuxnet hid its presence from both users and security tools. It intercepted API calls to conceal malicious files and registry entries, making detection extremely difficult.

Targeted PLC Payload
Stuxnet specifically targeted Siemens Step7 software, altering frequency-converter outputs so that centrifuges spun outside safe operating parameters. Simultaneously, it reported normal operation to supervisory systems, delaying discovery of the physical sabotage.

C&C Infrastructure
Infected systems periodically connected to hardcoded C&C domains. If the domain wasn’t available, they attempted a fallback sequence based on an algorithm until a valid server was found.

Stuxnet’s sophistication illustrates how a well-resourced adversary can combine multiple tactics—zero days, rootkits, and specialized payloads—to achieve a strategic objective. Defending against such threats requires not only patching known vulnerabilities but also employing heuristic detection (monitoring for unusual PLC-related traffic) and isolating critical industrial systems from standard corporate networks.
Conclusion & Next Steps

# Finishing up

Malware continues to evolve, but by understanding the underlying techniques, the taxonomy of malware, persistence mechanisms, and network indicators—we can build robust defenses. Key takeaways:

**Layered Security**: Combine network-level monitoring (IDS/IPS, DNS filtering) with endpoint protections (EDR, whitelisting) and continuous patch management.

**Behavioral Analysis**: Static signatures alone are no longer sufficient; tools that detect anomalous process behavior catch zero-day variants.

**User Education**: People remain the most common weak link. Regular training, phishing simulations, and clear reporting mechanisms help reduce successful social engineering.

**Incident Response Planning**: Develop and rehearse IR playbooks for malware outbreaks—identify infected systems, isolate them, and perform forensic analysis without contaminating evidence.

# Great Tools & Resources

Wireshark: For packet-level inspection of suspicious traffic.

CyberChef: For quick decoding, decryption, and forensic string extraction.

VirusTotal: To check file hashes or URLs against a large database of known malware.

Malware Analysis Sandboxes (Cuckoo, Any.Run): Safe environments for dynamic analysis.

Threat Intelligence Feeds (AlienVault OTX, AbuseIPDB): For up-to-date indicators of compromise (IoCs).

